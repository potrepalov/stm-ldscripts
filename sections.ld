/* ldscripts/sections.ld */


/*
 * Linker script for STM32Fxxx.
 */

/*
 * The '__stack' definition is required by crt0, do not remove it.
 */

ENTRY( Reset_Handler );


USE_STACK_REGION = (ORIGIN(REGION_STACK) == ORIGIN(REGION_DATA)) ? 0 : 1;
USE_HEAP_REGION = (ORIGIN(REGION_HEAP) == ORIGIN(REGION_DATA)) ? 0 : 1;


__stack =
  USE_STACK_REGION ?
      ORIGIN(REGION_STACK) + LENGTH(REGION_STACK)
    : ORIGIN(REGION_DATA) + LENGTH(REGION_DATA);

_estack = __stack; 	/* STM specific definition */

/*
 * Default stack sizes.
 * These are used by the startup in order to allocate stacks 
 * for the different modes.
 */

__Main_Stack_Size = 1024 ;

/*
 * "PROVIDE" allows to easily override these values from an object file
 * or the command line.
 */
PROVIDE ( _Main_Stack_Size = __Main_Stack_Size ) ;

__Main_Stack_Limit = __stack  - _Main_Stack_Size ;

PROVIDE ( _Main_Stack_Limit = __Main_Stack_Limit ) ;

/*
 * There will be a link error if there is not this amount of 
 * RAM free at the end. 
 */
_Minimum_Stack_Size = 256 ;

/*
 * Default heap definitions.
 * The heap start immediately after the last statically allocated 
 * .sbss/.noinit section, and extends up to the main stack limit.
 */

IS_HEAP_BEFORE_STACK =
  USE_HEAP_REGION ?
      (( USE_STACK_REGION ?
          ( ORIGIN(REGION_STACK) == ORIGIN(REGION_HEAP) ? 1 : 0 )
        : 0 ))
    : (( USE_STACK_REGION ?
          ( ORIGIN(REGION_STACK) == ORIGIN(REGION_DATA) ? 1 : 0 )
	: 1 ));


PROVIDE ( _Heap_Begin = USE_HEAP_REGION ? ORIGIN(REGION_HEAP) : _end_noinit ) ;
PROVIDE ( _Heap_Limit =
  IS_HEAP_BEFORE_STACK ?
      (__stack - _Main_Stack_Size)
    : ( USE_HEAP_REGION ? 
            ORIGIN(REGION_HEAP) + LENGTH(REGION_HEAP)
	  : ORIGIN(REGION_DATA) + LENGTH(REGION_DATA) )  );



/* Sections Definitions */

SECTIONS
{
	/*
	 * For Cortex-M devices, the beginning of the startup code is stored in
	 * the .isr_vector section, which goes to FLASH.
	 */
	.text.isr_vector :
	{
		. = ALIGN(4);

		KEEP(*(.isr_vector))     	/* Interrupt vectors */
		KEEP(*(.cfmconfig))		/* Freescale configuration words */   

		. = ALIGN(4);
	/* 
	 * This section is here for convenience, to store the
	 * startup code at the beginning of the flash area, hoping that
	 * this will increase the readability of the listing.
	 */
		*(SORT(.after_vectors.*))       *(.after_vectors)

		. = ALIGN(4);
	} > REGION_TEXT


	/*
	 * For some STRx devices, the beginning of the startup code
	 * is stored in the .flashtext section, which goes to FLASH.
	 */
	.text.flashtext :
	{
		. = ALIGN(4);
		KEEP(*(SORT(.flashtext.*)))  KEEP(*(.flashtext))
		. = ALIGN(4);
	} > REGION_TEXT
 
    
	/*
	 * The program code is stored in the .text section, which goes to FLASH.
	 */
	.text :
	{
		. = ALIGN(4);

		*(SORT(.text.silOS.*))  *(.text.silOS)
		*(SORT(.text.*))        *(.text)
		*(SORT(.rodata.*))      *(.rodata)

		. = ALIGN(4);

		*(vtable)			/* C++ virtual tables */

		. = ALIGN(4);

		KEEP(*(.eh_frame*))

		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
		*(.glue_7)
		*(.glue_7t)

		. = ALIGN(4);
	} > REGION_TEXT

	/* ARM magic sections */
	.text.ARM.extab :
	{
		. = ALIGN(4);
		*(.ARM.extab* .gnu.linkonce.armextab.*)
		. = ALIGN(4);
	} > REGION_TEXT
   	
	__exidx_start = .;
	.text.ARM.exidx :
	{
		. = ALIGN(4);
		*(.ARM.exidx* .gnu.linkonce.armexidx.*)
		. = ALIGN(4);
	} > REGION_TEXT
   	__exidx_end = .;

	. = ALIGN(4);
	_etext = .;
	__etext = .;



	/*
	 * The initialised data section.
	 * The program executes knowing that the data is in the RAM
	 * but the loader puts the initial values in the FLASH (inidata).
	 * It is one task of the startup to copy the initial values from 
	 * FLASH to RAM.
	 */

	.text.inits :
	{
		. = ALIGN(4);
	/*
	 * These are the old initialisation sections, intended to contain
	 * naked code, with the prologue/epilogue added by crti.o/crtn.o
	 * when linking with startup files. The standalone startup code
	 * currently does not run these, better use the init arrays below.
		KEEP(*(.init))
		KEEP(*(.fini))

		. = ALIGN(4);
	 */

	/*
	 * The preinit code, i.e. an array of pointers to initialisation 
	 * functions to be performed before constructors.
	 */
		PROVIDE_HIDDEN (__preinit_array_start = .);

		KEEP(*(SORT(.preinit_array_sysinit.*)))
		KEEP(*(.preinit_array_sysinit))

		KEEP(*(SORT(.preinit_array_platform.*)))
		KEEP(*(.preinit_array_platrorm))

		KEEP(*(SORT(.preinit_array.*)))
		KEEP(*(.preinit_array))

		PROVIDE_HIDDEN (__preinit_array_end = .);

		. = ALIGN(4);

		PROVIDE_HIDDEN (__zero_table_start__ = .);

		LONG( ADDR(.bss_CCMRAM) )
		LONG( SIZEOF(.bss_CCMRAM) )

		LONG( ADDR(.bss_SRAM1) )
		LONG( SIZEOF(.bss_SRAM1) )

		LONG( ADDR(.bss_SRAM2) )
		LONG( SIZEOF(.bss_SRAM2) )

		LONG( ADDR(.bss_SRAM3) )
		LONG( SIZEOF(.bss_SRAM3) )

		LONG( ADDR(.bss_BIT_BAND) )
		LONG( SIZEOF(.bss_BIT_BAND) )

		LONG( ADDR(.bss) )
		LONG( SIZEOF(.bss) )

		PROVIDE_HIDDEN (__zero_table_end__ = .);

		PROVIDE_HIDDEN (__copy_table_start__ = .);

		LONG( LOADADDR(.data_CCMRAM) )
		LONG( ADDR(.data_CCMRAM) )
		LONG( SIZEOF(.data_CCMRAM) )

		LONG( LOADADDR(.data_SRAM1) )
		LONG( ADDR(.data_SRAM1) )
		LONG( SIZEOF(.data_SRAM1) )

		LONG( LOADADDR(.data_SRAM2) )
		LONG( ADDR(.data_SRAM2) )
		LONG( SIZEOF(.data_SRAM2) )

		LONG( LOADADDR(.data_SRAM3) )
		LONG( ADDR(.data_SRAM3) )
		LONG( SIZEOF(.data_SRAM3) )

		LONG( LOADADDR(.data_BIT_BAND) )
		LONG( ADDR(.data_BIT_BAND) )
		LONG( SIZEOF(.data_BIT_BAND) )

		LONG( LOADADDR(.data) )
		LONG( ADDR(.data) )
		LONG( SIZEOF(.data) )

		PROVIDE_HIDDEN (__copy_table_end__ = .);

	/*
	 * The init code, i.e. an array of pointers to static constructors.
	 */
		PROVIDE_HIDDEN (__init_array_start = .);

		KEEP(*(SORT(.init_array.*)))
		KEEP(*(.init_array))

		PROVIDE_HIDDEN (__init_array_end = .);

		. = ALIGN(4);

	/*
	 * The fini code, i.e. an array of pointers to static destructors.
	 */
		PROVIDE_HIDDEN (__fini_array_start = .);

		KEEP(*(SORT(.fini_array.*)))
		KEEP(*(.fini_array))

		PROVIDE_HIDDEN (__fini_array_end = .);

		. = ALIGN(4);
	} > REGION_TEXT


	.data_CCMRAM :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.ccmram.*))   *(.data_begin.ccmram)
		*(SORT(.data_begin.CCMRAM.*))   *(.data_begin.CCMRAM)
		*(SORT(.data.ccmram.*))         *(.data.ccmram)
		*(SORT(.data.CCMRAM.*))         *(.data.CCMRAM)
		*(SORT(.data_end.ccmram.*))     *(.data_end.ccmram)
		*(SORT(.data_end.CCMRAM.*))     *(.data_end.CCMRAM)

		. = ALIGN(4);
	} > CCMRAM  AT > REGION_TEXT


	.data_SRAM1 :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.sram1.*))  *(.data_begin.sram1)
		*(SORT(.data_begin.SRAM1.*))  *(.data_begin.SRAM1)
		*(SORT(.data.sram1.*))        *(.data.sram1)
		*(SORT(.data.SRAM1.*))        *(.data.SRAM1)
		*(SORT(.data_end.sram1.*))    *(.data_end.sram1)
		*(SORT(.data_end.SRAM1.*))    *(.data_end.SRAM1)

		. = ALIGN(4);
	} > SRAM1  AT > REGION_TEXT


	.data_SRAM2 :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.sram2.*))  *(.data_begin.sram2)
		*(SORT(.data_begin.SRAM2.*))  *(.data_begin.SRAM2)
		*(SORT(.data.sram2.*))        *(.data.sram2)
		*(SORT(.data.SRAM2.*))        *(.data.SRAM2)
		*(SORT(.data_end.sram2.*))    *(.data_end.sram2)
		*(SORT(.data_end.SRAM2.*))    *(.data_end.SRAM2)

		. = ALIGN(4);
	} > SRAM2  AT > REGION_TEXT


	.data_SRAM3 :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.sram3.*))  *(.data_begin.sram3)
		*(SORT(.data_begin.SRAM3.*))  *(.data_begin.SRAM3)
		*(SORT(.data.sram3.*))        *(.data.sram3)
		*(SORT(.data.SRAM3.*))        *(.data.SRAM3)
		*(SORT(.data_end.sram3.*))    *(.data_end.sram3)
		*(SORT(.data_end.SRAM3.*))    *(.data_end.SRAM3)

		. = ALIGN(4);
	} > SRAM3  AT > REGION_TEXT


	.data_BIT_BAND :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.bit_band.*))  *(.data_begin.bit_band)
		*(SORT(.data_begin.BIT_BAND.*))  *(.data_begin.BIT_BAND)
		*(SORT(.data.bit_band.*))        *(.data.bit_band)
		*(SORT(.data.BIT_BAND.*))        *(.data.BIT_BAND)
		*(SORT(.data_end.bit_band.*))    *(.data_end.bit_band)
		*(SORT(.data_end.BIT_BAND.*))    *(.data_end.BIT_BAND)

		. = ALIGN(4);
	} > BIT_BAND  AT > REGION_TEXT


	.data :
	{
		. = ALIGN(4);

		*(SORT(.data_begin.*))  *(.data_begin)
		*(SORT(.data.*))        *(.data)
		*(SORT(.data_end.*))    *(.data_end)

		. = ALIGN(4);
	} > REGION_DATA  AT > REGION_TEXT

	PROVIDE( _image_end = LOADADDR( .data ) + SIZEOF( .data ) );




	/*
	 * The uninitialised data section. NOLOAD is used to avoid
	 * the "section `.bss' type changed to PROGBITS" warning
	 */

	.bss_CCMRAM (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.ccmram.*))    *(.bss_begin.ccmram)
		*(SORT(.bss_begin.CCMRAM.*))    *(.bss_begin.CCMRAM)
		*(SORT(.bss.ccmram.*))          *(.bss.ccmram)
		*(SORT(.bss.CCMRAM.*))          *(.bss.CCMRAM)
		*(SORT(.bss_end.ccmram.*))      *(.bss_end.ccmram)
		*(SORT(.bss_end.CCMRAM.*))      *(.bss_end.CCMRAM)

		. = ALIGN(4);
	} > CCMRAM


	.bss_SRAM1 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.sram1.*))     *(.bss_begin.sram1)
		*(SORT(.bss_begin.SRAM1.*))     *(.bss_begin.SRAM1)
		*(SORT(.bss.sram1.*))           *(.bss.sram1)
		*(SORT(.bss.SRAM1.*))           *(.bss.SRAM1)
		*(SORT(.bss_end.sram1.*))       *(.bss_end.sram1)
		*(SORT(.bss_end.SRAM1.*))       *(.bss_end.SRAM1)

		. = ALIGN(4);
	} > SRAM1


	.bss_SRAM2 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.sram2.*))     *(.bss_begin.sram2)
		*(SORT(.bss_begin.SRAM2.*))     *(.bss_begin.SRAM2)
		*(SORT(.bss.sram2.*))           *(.bss.sram2)
		*(SORT(.bss.SRAM2.*))           *(.bss.SRAM2)
		*(SORT(.bss_end.sram2.*))       *(.bss_end.sram2)
		*(SORT(.bss_end.SRAM2.*))       *(.bss_end.SRAM2)

		. = ALIGN(4);
	} > SRAM2


	.bss_SRAM3 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.sram3.*))     *(.bss_begin.sram3)
		*(SORT(.bss_begin.SRAM3.*))     *(.bss_begin.SRAM3)
		*(SORT(.bss.sram3.*))           *(.bss.sram3)
		*(SORT(.bss.SRAM3.*))           *(.bss.SRAM3)
		*(SORT(.bss_end.sram3.*))       *(.bss_end.sram3)
		*(SORT(.bss_end.SRAM3.*))       *(.bss_end.SRAM3)

		. = ALIGN(4);
	} > SRAM3


	.bss_BIT_BAND (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.bit_band.*))     *(.bss_begin.bit_band)
		*(SORT(.bss_begin.BIT_BAND.*))     *(.bss_begin.BIT_BAND)
		*(SORT(.bss.bit_band.*))           *(.bss.bit_band)
		*(SORT(.bss.BIT_BAND.*))           *(.bss.BIT_BAND)
		*(SORT(.bss_end.bit_band.*))       *(.bss_end.bit_band)
		*(SORT(.bss_end.BIT_BAND.*))       *(.bss_end.BIT_BAND)

		. = ALIGN(4);
	} > BIT_BAND


	.bss (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.bss_begin.*))           *(.bss_begin)
		*(SORT(.bss.*))                 *(.bss)
		*(SORT(.bss_end.*))             *(.bss_end)

		. = ALIGN(4);
	} > REGION_DATA





	.noinit_CCMRAM (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.noinit_begin.ccmram.*))    *(.noinit_begin.ccmram)
		*(SORT(.noinit_begin.CCMRAM.*))    *(.noinit_begin.CCMRAM)
		*(SORT(.noinit.ccmram.*))          *(.noinit.ccmram)
		*(SORT(.noinit.CCMRAM.*))          *(.noinit.CCMRAM)
		*(SORT(.noinit_end.ccmram.*))      *(.noinit_end.ccmram)
		*(SORT(.noinit_end.CCMRAM.*))      *(.noinit_end.CCMRAM)

		. = ALIGN(4);
	} > CCMRAM


	.noinit_SRAM1 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.noinit_begin.sram1.*))     *(.noinit_begin.sram1)
		*(SORT(.noinit_begin.SRAM1.*))     *(.noinit_begin.SRAM1)
		*(SORT(.noinit.sram1.*))           *(.noinit.sram1)
		*(SORT(.noinit.SRAM1.*))           *(.noinit.SRAM1)
		*(SORT(.noinit_end.sram1.*))       *(.noinit_end.sram1)
		*(SORT(.noinit_end.SRAM1.*))       *(.noinit_end.SRAM1)

		. = ALIGN(4);
	} > SRAM1


	.noinit_SRAM2 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.noinit_begin.sram2.*))     *(.noinit_begin.sram2)
		*(SORT(.noinit_begin.SRAM2.*))     *(.noinit_begin.SRAM2)
		*(SORT(.noinit.sram2.*))           *(.noinit.sram2)
		*(SORT(.noinit.SRAM2.*))           *(.noinit.SRAM2)
		*(SORT(.noinit_end.sram2.*))       *(.noinit_end.sram2)
		*(SORT(.noinit_end.SRAM2.*))       *(.noinit_end.SRAM2)

		. = ALIGN(4);
	} > SRAM2


	.noinit_SRAM3 (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.noinit_begin.sram3.*))     *(.noinit_begin.sram3)
		*(SORT(.noinit_begin.SRAM3.*))     *(.noinit_begin.SRAM3)
		*(SORT(.noinit.sram3.*))           *(.noinit.sram3)
		*(SORT(.noinit.SRAM3.*))           *(.noinit.SRAM3)
		*(SORT(.noinit_end.sram3.*))       *(.noinit_end.sram3)
		*(SORT(.noinit_end.SRAM3.*))       *(.noinit_end.SRAM3)

		. = ALIGN(4);
	} > SRAM3


	.noinit_BIT_BAND (NOLOAD) :
	{
		. = ALIGN(4);

		*(SORT(.noinit_begin.bit_band.*))     *(.noinit_begin.bit_band)
		*(SORT(.noinit_begin.BIT_BAND.*))     *(.noinit_begin.BIT_BAND)
		*(SORT(.noinit.bit_band.*))           *(.noinit.bit_band)
		*(SORT(.noinit.BIT_BAND.*))           *(.noinit.BIT_BAND)
		*(SORT(.noinit_end.bit_band.*))       *(.noinit_end.bit_band)
		*(SORT(.noinit_end.BIT_BAND.*))       *(.noinit_end.BIT_BAND)

		. = ALIGN(4);
	} > BIT_BAND


	.noinit_EXTMEM (NOLOAD) :
	{
		. = ALIGN(4);
		*(SORT(.noinit_begin.extmem.*))       *(.noinit_begin.extmem)
		*(SORT(.noinit_begin.EXTMEM.*))       *(.noinit_begin.EXTMEM)
		*(SORT(.noinit.extmem.*))             *(.noinit.extmem)
		*(SORT(.noinit.EXTMEM.*))             *(.noinit.EXTMEM)
		*(SORT(.noinit_end.extmem.*))         *(.noinit_end.extmem)
		*(SORT(.noinit_end.EXTMEM.*))         *(.noinit_end.EXTMEM)
		. = ALIGN(4);
	} > EXTMEM


	.noinit_BACKUP (NOLOAD) :
	{
		. = ALIGN(4);
		*(SORT(.noinit_begin.backup.*))   *(.noinit_begin.backup)
		*(SORT(.noinit_begin.BACKUP.*))   *(.noinit_begin.BACKUP)
		*(SORT(.noinit_begin.bkpsram.*))  *(.noinit_begin.bkpsram)
		*(SORT(.noinit_begin.BKPSRAM.*))  *(.noinit_begin.BKPSRAM)
		*(SORT(.noinit.backup.*))         *(.noinit.backup)
		*(SORT(.noinit.BACKUP.*))         *(.noinit.BACKUP)
		*(SORT(.noinit.bkpsram.*))        *(.noinit.bkpsram)
		*(SORT(.noinit.BKPSRAM.*))        *(.noinit.BKPSRAM)
		*(SORT(.noinit_end.backup.*))     *(.noinit_end.backup)
		*(SORT(.noinit_end.BACKUP.*))     *(.noinit_end.BACKUP)
		*(SORT(.noinit_end.bkpsram.*))    *(.noinit_end.bkpsram)
		*(SORT(.noinit_end.BKPSRAM.*))    *(.noinit_end.BKPSRAM)
		. = ALIGN(4);
	} > BKPSRAM


	.sram1 (NOLOAD) :
	{
		*(SORT(.sram1.*))  *(.sram1)
	} > SRAM1

	.sram2 (NOLOAD) :
	{
		*(SORT(.sram2.*))  *(.sram2)
	} > SRAM2

	.sram3 (NOLOAD) :
	{
		*(SORT(.sram3.*))  *(.sram3)
	} > SRAM3


	.noinit (NOLOAD) :
	{
		. = ALIGN(4);
		HIDDEN( __noinit_start__ = . );
		_noinit = .;

		*(SORT(.noinit_begin.*))           *(.noinit_begin)
		*(SORT(.noinit.*))                 *(.noinit)
		*(SORT(.noinit_end.*))             *(.noinit_end)

		. = ALIGN(4);
		HIDDEN( __noinit_end__ = .);
		_end_noinit = .;
	} > REGION_DATA

	/* Mandatory to be word aligned, _sbrk assumes this */
	PROVIDE ( end = _end_noinit ); /* was _ebss */
	PROVIDE ( _end = _end_noinit );
	PROVIDE ( __end = _end_noinit );
	PROVIDE ( __end__ = _end_noinit );
    

	/*
	 * Used for validation only, do not allocate anything here!
	 *
	 * This is just to check that there is enough RAM left for the Main
	 * stack. It should generate an error if it's full.
	 */
	._check_stack :
	{
		. = ALIGN(8);

		. = . + _Minimum_Stack_Size ;

		. = ALIGN(8);
	} > REGION_STACK



	/*
	 * The FLASH Bank1.
	 * The C or assembly source must explicitly place the code 
	 * or data there using the "section" attribute.
	 */
	.b1text :
	{
		*(.b1text)                   /* remaining code */
		*(.b1rodata)                 /* read-only data (constants) */
		*(.b1rodata.*)
	} >FLASHB1

	/*
	 * The EXTMEM.
	 * The C or assembly source must explicitly place the code or data there
	 * using the "section" attribute.
	 */

	/* EXTMEM Bank1 */
	.eb1text :
	{
		*(.eb1text)                   /* remaining code */
		*(.eb1rodata)                 /* read-only data (constants) */
		*(.eb1rodata.*)
	} >EXTMEMB1

	/* EXTMEM Bank2 */
	.eb2text :
	{
		*(.eb2text)                   /* remaining code */
		*(.eb2rodata)                 /* read-only data (constants) */
		*(.eb2rodata.*)
	} >EXTMEMB2

	/* EXTMEM Bank3 */
	.eb3text :
	{
		*(.eb3text)                   /* remaining code */
		*(.eb3rodata)                 /* read-only data (constants) */
		*(.eb3rodata.*)
	} >EXTMEMB3

	/* EXTMEM Bank4 */
	.eb4text :
	{
		*(.eb4text)                   /* remaining code */
		*(.eb4rodata)                 /* read-only data (constants) */
		*(.eb4rodata.*)
	} >EXTMEMB4

	/* EXTMEM Bank5 */
	.eb5text :
	{
		*(.eb5text)                   /* remaining code */
		*(.eb5rodata)                 /* read-only data (constants) */
		*(.eb5rodata.*)
	} >EXTMEMB5

	/* EXTMEM Bank6 */
	.eb6text :
	{
		*(.eb6text)                   /* remaining code */
		*(.eb6rodata)                 /* read-only data (constants) */
		*(.eb6rodata.*)
	} >EXTMEMB6


	/* After that there are only debugging sections. */

	/* This can remove the debugging information from the standard libraries */    
	/* 
	DISCARD :
	{
		libc.a ( * )
		libm.a ( * )
		libgcc.a ( * )
	}
	 */

	/* Stabs debugging sections.  */
	.stab          0 : { *(.stab) }
	.stabstr       0 : { *(.stabstr) }
	.stab.excl     0 : { *(.stab.excl) }
	.stab.exclstr  0 : { *(.stab.exclstr) }
	.stab.index    0 : { *(.stab.index) }
	.stab.indexstr 0 : { *(.stab.indexstr) }
	.comment       0 : { *(.comment) }

	/*
	 * DWARF debug sections.
	 * Symbols in the DWARF debugging sections are relative to the beginning
	 * of the section so we begin them at 0.  
	 */
	/* DWARF 1 */
	.debug          0 : { *(.debug) }
	.line           0 : { *(.line) }

	/* GNU DWARF 1 extensions */
	.debug_srcinfo  0 : { *(.debug_srcinfo) }
	.debug_sfnames  0 : { *(.debug_sfnames) }

	/* DWARF 1.1 and DWARF 2 */
	.debug_aranges  0 : { *(.debug_aranges) }
	.debug_pubnames 0 : { *(.debug_pubnames) }

	/* DWARF 2 */
	.debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
	.debug_abbrev   0 : { *(.debug_abbrev) }
	.debug_line     0 : { *(.debug_line) }
	.debug_frame    0 : { *(.debug_frame) }
	.debug_str      0 : { *(.debug_str) }
	.debug_loc      0 : { *(.debug_loc) }
	.debug_macinfo  0 : { *(.debug_macinfo) }

	/* SGI/MIPS DWARF 2 extensions */
	.debug_weaknames 0 : { *(.debug_weaknames) }
	.debug_funcnames 0 : { *(.debug_funcnames) }
	.debug_typenames 0 : { *(.debug_typenames) }
	.debug_varnames  0 : { *(.debug_varnames) }    
}


/* End of file  sections.ld */
